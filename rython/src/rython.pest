import_stmt = { "import" ~ import_name ~ ("," ~ import_name)* }
from_import_stmt = { "from" ~ import_level? ~ module_path ~ "import" ~ import_name ~ ("," ~ import_name)* }
import_level = { "."+ }
module_path = { identifier ~ ("." ~ identifier)* }
import_name = { identifier ~ ("as" ~ identifier)? }

// Enhanced expressions
expression = { 
    (unary_op ~ term) | term ~ (bin_op ~ term)* ~ (compare_op ~ term)* 
}
unary_op = { "not" | "-" | "+" | "~" }
bin_op = { "+" | "-" | "*" | "/" | "%" | "**" | "//" }
compare_op = { "==" | "!=" | "<" | "<=" | ">" | ">=" | "is" ~ "not"? | "not"? ~ "in" }

// Lists and dicts
list_literal = { "[" ~ (expression ~ ("," ~ expression)*)? ~ ","? ~ "]" }
dict_literal = { "{" ~ (dict_item ~ ("," ~ dict_item)*)? ~ ","? ~ "}" }
dict_item = { expression ~ ":" ~ expression }

// Function calls with kwargs
call_args = { (expression | kwarg) ~ ("," ~ (expression | kwarg))* }
kwarg = { identifier ~ "=" ~ expression }

// Type annotations
type_annotation = { ":" ~ type }
type = { 
    "int" | "float" | "str" | "bool" | "None" | "Any" |
    "List[" ~ type ~ "]" |
    "Dict[" ~ type ~ "," ~ type ~ "]"
}

// Control flow enhancements
if_stmt = { 
    "if" ~ condition ~ ":" ~ block ~ 
    ("elif" ~ condition ~ ":" ~ block)* ~ 
    ("else" ~ ":" ~ block)?
}
for_stmt = { "for" ~ expression ~ "in" ~ expression ~ ":" ~ block ~ ("else" ~ ":" ~ block)? }
while_stmt = { "while" ~ condition ~ ":" ~ block ~ ("else" ~ ":" ~ block)? }

// Simple statements
pass_stmt = { "pass" }
break_stmt = { "break" }
continue_stmt = { "continue" }